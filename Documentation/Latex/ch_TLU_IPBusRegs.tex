\chapter{IPBus Registers}\label{ch:ipbusregs}
%
%\begin{table}[]
%\centering
%\caption{My caption}
%\label{my-label}
%\begin{tabular}{|l|l|r|l|l|l|l|l|}
%\hline
%\textbf{NODE} & \textbf{SUBNODE} & \multicolumn{1}{l|}{\textbf{ADDRESS}} & \textbf{MASK} & \textbf{PERMISSION} & \textbf{DESCRIPTION} & \textbf{MODE} & \textbf{SIZE} \\ \hline
%ID & TLU & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{version} &  & 0x1 &  & r & firmware version &  &  \\
% &  & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{DUTInterfaces} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x1000}} & \textbf{} & \textbf{} & \textbf{DUT Interfaces control registers} & \textbf{} & \textbf{} \\
% & DUTMaskW & 0x0 &  & w &  &  &  \\
% & IgnoreDUTBusyW & 0x1 &  & w &  &  &  \\
% & IgnoreShutterVetoW & 0x2 &  & w &  &  &  \\
% & DUTInterfaceModeW & 0x3 &  & w &  &  &  \\
% & DUTInterfaceModeModifierW & 0x4 &  & w &  &  &  \\
% & DUTInterfaceModeR & 0xB &  & r &  &  &  \\
% & DUTInterfaceModeModifierR & 0xC &  & r &  &  &  \\
% & DUTMaskR & 0x8 &  & r &  &  &  \\
% & IgnoreDUTBusyR & 0x9 &  & r &  &  &  \\
% & IgnoreShutterVetoR & 0xA &  & r &  &  &  \\
% &  & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{Shutter} &  & \multicolumn{1}{l|}{\textbf{0x2000}} & \textbf{} & \textbf{} & \textbf{Shutter/T0 control} & \textbf{} &  \\
% & ShutterStateW & 0x0 &  & w &  &  &  \\
% & PulseT0 & 0x1 &  & w &  &  &  \\
% &  & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{i2c\_master} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x3000}} & \textbf{} & \textbf{} & \textbf{I2C Master interface} & \textbf{} & \textbf{} \\
% & i2c\_pre\_lo & 0x0 & 0xFF & r/w &  &  &  \\
% & i2c\_pre\_hi & 0x1 & 0xFF & r/w &  &  &  \\
% & i2c\_ctrl & 0x2 & 0xFF & r/w &  &  &  \\
% & i2c\_rxtx & 0x3 & 0xFF & r/w &  &  &  \\
% & i2c\_cmdstatus & 0x4 & 0xFF & r/w &  &  &  \\
% &  & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{eventBuffer} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x4000}} & \textbf{} & \textbf{} & \textbf{Event buffer} & \textbf{} & \textbf{} \\
% & EventFifoData & 0x0 &  & r &  & non-incremental & 3200 \\
% & EventFifoFillLevel & 0x1 &  & r &  &  &  \\
% & EventFifoCSR & 0x2 &  & r/w &  &  &  \\
% & EventFifoFillLevelFlags & 0x3 &  & r &  &  &  \\
% &  & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{Event\_Formatter} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x5000}} & \textbf{} & \textbf{} & \textbf{Event formatter configuration} & \textbf{} & \textbf{} \\
% & Enable\_Record\_Data & 0x0 &  & r/w &  &  &  \\
% & ResetTimestampW & 0x1 &  & w &  &  &  \\
% & CurrentTimestampLR & 0x2 &  & r &  &  &  \\
% & CurrentTimestampHR & 0x3 &  & r &  &  &  \\
% &  & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{triggerInputs} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x6000}} & \textbf{} & \textbf{} & \textbf{Inputs configuration} & \textbf{} & \textbf{} \\
% & SerdesRstW & 0x0 &  & w &  &  &  \\
% & SerdesRstR & 0x8 &  & r &  &  &  \\
% & ThrCount0R & 0x9 &  & r &  &  &  \\
% & ThrCount1R & 0xA &  & r &  &  &  \\
% & ThrCount2R & 0xB &  & r &  &  &  \\
% & ThrCount3R & 0xC &  & r &  &  &  \\
% & ThrCount4R & 0xD &  & r &  &  &  \\
% & ThrCount5R & 0xE &  & r &  &  &  \\
% &  & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{triggerLogic} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x7000}} & \textbf{} & \textbf{} & \textbf{Trigger logic configuration} & \textbf{} & \textbf{} \\
% & PostVetoTriggersR & 0x10 &  & r &  &  &  \\
% & PreVetoTriggersR & 0x11 &  & r &  &  &  \\
% & InternalTriggerIntervalW & 0x02 &  & w &  &  &  \\
% & InternalTriggerIntervalR & 0x12 &  & r &  &  &  \\
% & TriggerVetoW & 0x04 &  & w &  &  &  \\
% & TriggerVetoR & 0x14 &  & r &  &  &  \\
% & ExternalTriggerVetoR & 0x15 &  & r &  &  &  \\
% & PulseStretchW & 0x06 &  & w &  &  &  \\
% & PulseStretchR & 0x16 &  & r &  &  &  \\
% & PulseDelayW & 0x07 &  & w &  &  &  \\
% & PulseDelayR & 0x17 &  & r &  &  &  \\
% & TriggerHoldOffW & 0x08 &  & w &  &  &  \\
% & TriggerHoldOffR & 0x18 &  & r &  &  &  \\
% & AuxTriggerCountR & 0x19 &  & r &  &  &  \\
% & TriggerPattern\_lowW & 0x0A &  & w &  &  &  \\
% & TriggerPattern\_lowR & 0x1A &  & r &  &  &  \\
% & TriggerPattern\_highW & 0x0B &  & w &  &  &  \\
% & TriggerPattern\_highR & 0x1B &  & r &  &  &  \\
% &  & \multicolumn{1}{l|}{} &  &  &  &  &  \\ \hline
%\textbf{logic\_clocks} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x8000}} & \textbf{} & \textbf{} & \textbf{Clocks configuration} & \textbf{} & \textbf{} \\
% & LogicClocksCSR & 0x0 &  & r/w &  &  &  \\
% & LogicRst & 0x1 &  & w &  &  &  \\ \hline
%\end{tabular}
%\end{table}

\begin{table}
\centering
\footnotesize
\caption{IPBus register}
\label{tab:ipbusreg}
\begin{tabular}{|l|l|r|l|l|}
\hline
\textbf{NODE} & \textbf{SUBNODE} & \multicolumn{1}{l|}{\textbf{ADDRESS}} & \textbf{MASK} & \textbf{PERMISSION} \\ \hline
\textbf{version} &  & 0x1 &  & r \\ \hline
\textbf{DUTInterfaces} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x1000}} & \textbf{} & \textbf{} \\
 & DUTMaskW & 0x0 &  & w \\
 & IgnoreDUTBusyW & 0x1 &  & w \\
 & IgnoreShutterVetoW & 0x2 &  & w \\
 & DUTInterfaceModeW & 0x3 &  & w \\
 & DUTInterfaceModeModifierW & 0x4 &  & w \\
 & DUTInterfaceModeR & 0xB &  & r \\
 & DUTInterfaceModeModifierR & 0xC &  & r \\
 & DUTMaskR & 0x8 &  & r \\
 & IgnoreDUTBusyR & 0x9 &  & r \\
 & IgnoreShutterVetoR & 0xA &  & r \\ \hline
\textbf{Shutter} &  & \multicolumn{1}{l|}{\textbf{0x2000}} & \textbf{} & \textbf{} \\
 & ShutterStateW & 0x0 &  & w \\
 & PulseT0 & 0x1 &  & w \\ \hline
\textbf{i2c\_master} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x3000}} & \textbf{} & \textbf{} \\
 & i2c\_pre\_lo & 0x0 & 0xFF & r/w \\
 & i2c\_pre\_hi & 0x1 & 0xFF & r/w \\
 & i2c\_ctrl & 0x2 & 0xFF & r/w \\
 & i2c\_rxtx & 0x3 & 0xFF & r/w \\
 & i2c\_cmdstatus & 0x4 & 0xFF & r/w \\ \hline
\textbf{eventBuffer} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x4000}} & \textbf{} & \textbf{} \\
 & EventFifoData & 0x0 &  & r \\
 & EventFifoFillLevel & 0x1 &  & r \\
 & EventFifoCSR & 0x2 &  & r/w \\
 & EventFifoFillLevelFlags & 0x3 &  & r \\ \hline
\textbf{Event\_Formatter} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x5000}} & \textbf{} & \textbf{} \\
 & Enable\_Record\_Data & 0x0 &  & r/w \\
 & ResetTimestampW & 0x1 &  & w \\
 & CurrentTimestampLR & 0x2 &  & r \\
 & CurrentTimestampHR & 0x3 &  & r \\ \hline
\textbf{triggerInputs} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x6000}} & \textbf{} & \textbf{} \\
 & SerdesRstW & 0x0 &  & w \\
 & SerdesRstR & 0x8 &  & r \\
 & ThrCount0R & 0x9 &  & r \\
 & ThrCount1R & 0xA &  & r \\
 & ThrCount2R & 0xB &  & r \\
 & ThrCount3R & 0xC &  & r \\
 & ThrCount4R & 0xD &  & r \\
 & ThrCount5R & 0xE &  & r \\ \hline
\textbf{triggerLogic} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x7000}} & \textbf{} & \textbf{} \\
 & PostVetoTriggersR & 0x10 &  & r \\
 & PreVetoTriggersR & 0x11 &  & r \\
 & InternalTriggerIntervalW & 0x02 &  & w \\
 & InternalTriggerIntervalR & 0x12 &  & r \\
 & TriggerVetoW & 0x04 &  & w \\
 & TriggerVetoR & 0x14 &  & r \\
 & ExternalTriggerVetoR & 0x15 &  & r \\
 & PulseStretchW & 0x06 &  & w \\
 & PulseStretchR & 0x16 &  & r \\
 & PulseDelayW & 0x07 &  & w \\
 & PulseDelayR & 0x17 &  & r \\
 & TriggerHoldOffW & 0x08 &  & w \\
 & TriggerHoldOffR & 0x18 &  & r \\
 & AuxTriggerCountR & 0x19 &  & r \\
 & TriggerPattern\_lowW & 0x0A &  & w \\
 & TriggerPattern\_lowR & 0x1A &  & r \\
 & TriggerPattern\_highW & 0x0B &  & w \\
 & TriggerPattern\_highR & 0x1B &  & r \\ \hline
\textbf{logic\_clocks} & \textbf{} & \multicolumn{1}{l|}{\textbf{0x8000}} & \textbf{} & \textbf{} \\
 & LogicClocksCSR & 0x0 &  & r/w \\
 & LogicRst & 0x1 &  & w \\ \hline
\end{tabular}
\end{table}

\begin{description}\label{ch:IPBus_DUT}
  \item[version] Returns the current version of firmware used to program the \gls{tlu}
  \item[------------------------]
  \item[DUTINTERFACES]
  \item[DUTMaskW] Writing to this register allows to define which \gls{dut}s are active when in AIDA mode. The lower 4 bits of the register can be used to define the status of the \gls{dut}s: 1 for active, 0 for masked. \verb|hdmi1| is defined by bit 0, \verb|hdmi2| is defined by bit 1, \verb|hdmi3| is defined by bit 2, \verb|hdmi4| is defined by bit 3.
  \item[IgnoreDUTBusyW] Writing to this register allows to ignore the busy signal from a particular \gls{dut} while in AIDA mode. The lower 4 bits are used to define the status for each device. A 1 indicates that the logic should ignore busy signals from the specific \gls{dut}.
  \item[IgnoreShutterVetoW] The \gls{lsb} of this register can be written to define whether the \gls{dut} should ignore the shutter veto signal. Normally, when the shutter signal is asserted the \gls{dut} reports busy. If this bit is flag the \gls{dut} will ignore the shutter signal.
  \item[DUTInterfaceModeW] Write register to define the mode of operation for a \gls{dut}. Two bits per device can be used to define the mode; currently only two modes are available (AIDA, EUDET) but the second but is reserved for additional modes introduced in the future.\\
      The bit pairs are packed from the \gls{lsb} starting with \verb|hdmi1| (bits 0, 1), \verb|hdmi2| (bits 2, 3), \verb|hdmi3| (bits 4, 5),  \verb|hdmi4| (bits 6, 7).
      \begin{itemize}
        \item bit pair \texttt{X0}: EUDET
        \item bit pair \texttt{X1}: AIDA
      \end{itemize}
  \item[DUTInterfaceModeModifierW] Write register. This register only affects the EUDET mode of operation. For each \gls{dut} two bits can be configured although cyrrently only the lower of the pair is considere. The bit packing is done in a manner similar to the DUTInterfaceMode. Set bit high to allow asynchronous veto using \verb|DUT_CLK| when in EUDET mode.
  \item[DUTInterfaceModeR] Read the content of the DUTInterfaceMode register.
  \item[DUTInterfaceModeModifierR] Read status of the DUTInterfaceMode register.
  \item[DUTMaskR] Read the status of the DUTMask register.
  \item[IgnoreDUTBusyR] Read the status of the IgnoreDUTBusy register.
  \item[IgnoreShutterVetoR] Read the status of the IgnoreShutterVeto word (only the last bit is meanigful).
\end{description}

\begin{description}
  \item[------------------------]
  \item[SHUTTER]
  \item[ShutterStateW] The \gls{lsb} of this register is propagated to the \gls{dut}s as shutter signal. This is the signal that the \gls{dut}s receive on the \verb|cont| line.
  \item[PulseT0] Writing to this register will cause the firmware to generate a T0 signal.
\end{description}

\begin{description}
  \item[------------------------]
  \item[I2C\_MASTER] This section includes registers used to talk to the \gls{i2c} bus.
  \item[i2c\_pre\_lo] Lower part of the clock pre-scaler value. The pre-scaler is used to reduce the clock frequency of the bus and make it compatible with the \gls{i2c} slaves on the board.
  \item[i2c\_pre\_hi] Higher part of the clock pre-scaler value.
  \item[i2c\_ctrl]
  \item[i2c\_rxtx]
  \item[i2c\_cmdstatus]
\end{description}

\begin{description}
  \item[------------------------]
  \item[EVENTBUFFER]
  \item[EventFifoData]      Returns the content of the \gls{fifo}. In the current firmware implementation the memory can hold 8192 words (32-bit).
  \item[EventFifoFillLevel] Read register. Returns the number of words written in the \gls{fifo}. The lowest 14-bits are the actual data.
  \item[EventFifoCSR]       Read or write register. When read it returns the status of the \gls{fifo}. Five flags are returned:
                              \begin{itemize}
                                \item bit 0: empty. Asserted when the \gls{fifo} is empty.
                                \item bit 1: almost empty. Asserted when one word remains in the \gls{fifo}.
                                \item bit 2: almost full. Asserted when the \gls{fifo} can only accept one more word before becoming full.
                                \item bit 3: full. In the current firmware the \gls{fifo} can hold 8192 words before filling up.
                                \item bit 4: programmable full. This signal is asserted when the number of words in the FIFO is greater than or equal to the assert threshold (8181). It is de-asserted when the number of words in the FIFO is less than the negate threshold (8180).
                              \end{itemize}
                                When any value is written to this register the \gls{fifo} is reset.
  \item[EventFifoFillLevelFlags] Does not do anything? REMOVE \textcolor[rgb]{1.00,0.00,0.00}{CHECK}
\end{description}

\begin{description}
  \item[------------------------]
  \item[EVENT\_FORMATTER]
  \item[Enable\_Record\_Data] Read and write register. When written, \textcolor[rgb]{1.00,0.00,0.00}{CHECK}\\
                                When read returns the content of the enable record word.
  \item[ResetTimestampW]        Write register. Writing any value to this register will cause the firmware to produce a retest timestamp signal (high for one clock cycle of clk\_4x\_logic). At the moment it does not seems to be connected to anything. \textcolor[rgb]{1.00,0.00,0.00}{CHECK}
  \item[CurrentTimestampLR] \textcolor[rgb]{1.00,0.00,0.00}{CHECK}
  \item[CurrentTimestampHR] \textcolor[rgb]{1.00,0.00,0.00}{CHECK}
\end{description}

\begin{description}
  \item[------------------------]
  \item[TRIGGERINPUTS]
  \item[SerdesRstW] Write register for the SerDes control.\begin{itemize}
                                                            \item bit 0: set this bit to reset the ISERDES
                                                            \item bit 1: set this bit to reset the input trigger counters
                                                            \item bit 2: \verb|s_calibrate_delay|
                                                          \end{itemize}
  \item[SerdesRstR] Read register for the SerDes control.
  \item[ThrCount0R] Read register. Returns the number of pulses above threshold for the trigger input.
  \item[ThrCount1R] Read register. Returns the number of pulses above threshold for the trigger input.
  \item[ThrCount2R] Read register. Returns the number of pulses above threshold for the trigger input.
  \item[ThrCount3R] Read register. Returns the number of pulses above threshold for the trigger input.
  \item[ThrCount4R] Read register. Returns the number of pulses above threshold for the trigger input.
  \item[ThrCount5R] Read register. Returns the number of pulses above threshold for the trigger input.
\end{description}

\begin{description}\label{ch:triggerLogicAdd}
  \item[------------------------]
  \item[TRIGGERLOGIC]
  \item[PostVetoTriggersR] Read register. Returns the number of triggers recorded in the \gls{tlu} after the veto is applied. These are the triggers actually sent to the \gls{dut}s.
  \item[PreVetoTriggersR] Read register. Returns the number of triggers recorded in the \gls{tlu} before the veto is applied. This is used for debugging purposes.
  \item[InternalTriggerIntervalW] Write the number of clock cycles to be used as period for the internal trigger generator. If this number is smaller than 5 then the triggers are disabled. Otherwise the period is number -2.
  \item[InternalTriggerIntervalR] Read the value written in InternalTriggerIntervalW.
  \item[TriggerVetoW] Write register. The value written to the \gls{lsb} of this register is used to generate a veto signal. This can be used to put switch the \gls{tlu} status: if the bit is asserted the logic will not send new triggers to the \gls{dut}s. If the bit is reset the board will process new triggers.
  \item[TriggerVetoR] Read the content of the TriggerVeto register.
  \item[ExternalTriggerVetoR] Read register. Bit 0 of this register reports the \verb|veto| status (1 for veto active, 0 for no veto). The veto is active if the \gls{tlu} buffer is full or if one of the \gls{dut}s is sending a veto signal.
  \item[PulseStretchW] Write the stretch word for the trigger pulses. The original trigger pulses collected at a trigger input can be stretched by $N$ cycles of the 4x clock (160~MHz, 6.25~ns). $N$ is a number between 0 and 31. The stretched pulse is always at least as long as the original input.\\
      The stretch values can be written in the \verb|conf| file using the parameters \verb|inX_STR| (X= [0 ... 5]).\\
      The six words for the inputs are packed in a single 32-bit word written to this register according to the format shown in table~\ref{tab:packing}.
  \item[PulseStretchR] Returns the content of the PulseStretch word.
  \item[PulseDelayW] Write the delay word for the trigger pulses. The original pulse is delayed by $N$ clycles of the 4x clock (160~MHz, 6.25~ns). $N$ is a number between 0 and 31. The six words for the inputs are packed in a single 32-bit word written to this register according to the format shown in table~\ref{tab:packing}.\\
      The delay values can be written in the \verb|conf| file using the parameters \verb|inX_DEL| (X= [0 ... 5]).\\
  \item[PulseDelayR] Returns the content of the PulseDelay word.
  \item[TriggerHoldOffW] Does not do anything? \textcolor[rgb]{1.00,0.00,0.00}{CHECK}
  \item[TriggerHoldOffR] Read the previous register... \textcolor[rgb]{1.00,0.00,0.00}{CHECK}
  \item[AuxTriggerCountR] Auxiliary trigger counter. Used for debug.
  \item[TriggerPattern\_lowW] Write register for the lower 32-bits of the trigger pattern. This pattern is used to select the combinations of trigger signals that produce a valid trigger in the \gls{tlu}. See section~\ref{ch:triggerLogic} for details.
  \item[TriggerPattern\_lowR] Read register for the lower 32-bits of the trigger pattern. This pattern is used to select the combinations of trigger signals that produce a valid trigger in the \gls{tlu}. See section~\ref{ch:triggerLogic} for details.
  \item[TriggerPattern\_highW] Write register for the higher 32-bits of the trigger pattern. This pattern is used to select the combinations of trigger signals that produce a valid trigger in the \gls{tlu}. See section~\ref{ch:triggerLogic} for details.
  \item[TriggerPattern\_highR] Read register for the higher 32-bits of the trigger pattern. This pattern is used to select the combinations of trigger signals that produce a valid trigger in the \gls{tlu}. See section~\ref{ch:triggerLogic} for details.
\end{description}

\begin{description}
  \item[------------------------]
  \item[LOGIC\_CLOCKS]
  \item[LogicClocksCSR] This is a read/write register. The write function is now obsolete and should be removed. Reading from this register returns the status of the PLL lock: bit 0 is the locked value of the pll (1= locked).
  \item[LogicRst] Writing a 1 in the LSB of this register will reset the PLL and the clocks used by the \gls{tlu} firmware. It needs to be checked for bugs.
\end{description}

\begin{sidewaystable}[]
\footnotesize
    \caption{Packing scheme for values in registers used to define the pulse stretch and delay.}
    \label{tab:packing}
    \begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|}
    \hline
    \multicolumn{32}{|c|}{Register value}                                                                                                                                                             \\ \hline
    31 & 30 & 29   & 28  & 27  & 26  & 25  & 24   & 23  & 22  & 21  & 20  & 19   & 18  & 17  & 16  & 15  & 14   & 13  & 12  & 11  & 10  & 9    & 8   & 7   & 6   & 5   & 4    & 3   & 2   & 1   & 0   \\ \hline
    x  & x  & \multicolumn{5}{c|}{Input 5} & \multicolumn{5}{c|}{Input 4} & \multicolumn{5}{c|}{Input 3} & \multicolumn{5}{c|}{Input 2} & \multicolumn{5}{c|}{Input 1} & \multicolumn{5}{c|}{Input 0} \\ \hline
    x  & x  & b4   & b3  & b2  & b1  & b0  & b4   & b3  & b2  & b1  & b0  & b4   & b3  & b2  & b1  & b0  & b4   & b3  & b2  & b1  & b0  & b4   & b3  & b2  & b1  & b0  & b4   & b3  & b2  & b1  & b0  \\ \hline
    \end{tabular}
\end{sidewaystable}
